Git 的分支，其本质上仅仅是指向提交对象的可变指针。实质上仅是包含所指对象校验和（长度为 40 的 SHA-1 值字符串）的文件，所以它的创建和销毁都非常高效。 创建一个新分支就相当于往一个文件中写入 41 个字节（40 个字符和 1 个换行符）

Git 中，HEAD 是一个指针，指向当前所在的本地分支（译注：将 HEAD 想象为当前分支的别名）。可简单理解为，HEAD 指向分支（branch），分支指向提交。

git branch 创建分支命令，仅仅只会创建一个新分支，并不会自动切换到新分支上去。

git checkout 分支切换命令，会改变你工作目录中的文件

git rm --cached <file> 删除命令时，会直接从暂存区删除文件（可以理解为取消跟踪），工作区则不做出改变。

git checkout -- 命令会用暂存区的文件替换工作区的文件，会清除所有工作区未添加到暂存区的改动

在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。

Git 系统跟踪的文件一般有 2 种状态，未修改（或已提交）和已修改。未修改意味着工作目录下的文件内容和最近一次提交的修订内容一致，很安全地存放在版本库中；如果工作目录下的文件和最近一次提交的版本存在差异，则被认为是已修改的文件。

文件出现了两次！一次已暂存，一次未暂存，是不是 Git 搞错了？

实际上 Git 只不过暂存了你运行 git add 命令时的版本，如果现在提交，那么提交的是添加注释前的版本，而非当前工作目录中的版本。所以，运行了 git add 之后又作了修订的文件，需要重新运行 git add 把最新版本暂存起来：

远程追踪分支是远程分支状态的引用。它们是你不能移动的本地引用，

git fetch 将远程仓库上，上一次 git fetch（pull）后的commit拉到本地。

git merge origin(远程仓库)/master(分支) 将 git fetch 获得的远程仓库上新的commit和本地所在分支合并

远程仓库的 conflict：当你和其他人在同一时间克隆，他们先推送到上游然后你再推送到上游，你的推送就会毫无疑问地被拒绝。 你必须先抓取他们的工作并将其合并进你的工作后才能推送。

	git branch：
	分支切换会改变你工作目录中的文件。在切换分支时，一定要注意你工作目录里的文件会被改变。 如果是切换到一个较旧的分支，你的工作目录会恢复到该分支最后一次提交时的样子。（建议实验验证 加深印象）
	
	Git 创建新分支的只是为你创建了一个可以移动的新的指针。
	Git 有一个名为 HEAD 的特殊指针，可以知道当前在哪一个分支上。
	Git 中，HEAD 是一个指针，指向当前所在的本地分支（注：可将 HEAD 想象为当前分支的别名）
	
	命令：你可以在不同分支间不断地来回切换和工作，并在时机成熟时将它们合并起来。 而所有这些工作，你需要的命令只有 branch、checkout 和 commit。
	git checkout 命令切换到一个已存在的分支，供你需要使用 。
	git log 命令查看各个分支当前所指的对象。
	
	git branch 命令仅仅创建一个新分支（ HEAD 指向同一个commit对象），并不会自动切换到新分支中去。	git branch 命令不只是可以创建与删除分支。 如果不加任何参数运行它，会得到当前所有分支的一个列表。
	(git checkout -b : 可以在创建新分支的同时切换到新分支。		git branch -d : 新分支完成功能 并在 master（原分支)合并新分支后 删除新分支)
	若 git branch 分支还包含了还未合并的工作，尝试使用 git branch -d 命令删除它时会失败。如果真的想要删除分支并丢掉那些工作可以使用 -D 选项强制删除它。
	git branch 选项 --merged 和 --no-merged 会在没有给定提交或分支名作为参数时， 分别列出已合并或未合并到当前分支的分支。
	
	fast-forward：
	当你试图 merge 两个分支时， 如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候， 只会简单的将指针向前推进，因为这种情况下的合并操作没有需要解决的分歧。
	
	merge conflict：
	 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们。
eg.
	 Git 会在有冲突的文件中加入标准的冲突解决标记，这样你可以打开这些包含冲突的文件然后手动解决冲突。 出现冲突的文件会包含一些特殊区段，看起来像下面这个样子：

		<<<<<<< HEAD:index.html
		<div id="footer">contact : email.support@github.com</div>
		=======
		<div id="footer">
		 please contact us at support@github.com
		</div>
		>>>>>>> iss53:index.html

	这表示 HEAD 所指示的版本（也就是你的 master (当前)分支所在的位置，因为你在运行 merge 命令的时候已经检出(checkout)到了这个分支）即在这个区段的上半部分（======= 的上半部分），而 iss53 (merge的)分支所指示的版本在 ======= 的下半部分。 为了解决冲突，你必须选择使用由 ======= 分割的两部分中的一个.
	
	修改后 commit -a -m "..." 即可解决冲突。 
	
	当你在（branch）的多个分支上进行修改（commit）合并（merge）这些操作后，这些分支全部都存于本地。 即你所有这一切都只发生在你本地的 Git 版本库中 —— 没有与服务器
	
若没有 git add 直接 git commit -m 会失败。可以使用 git commit -a -m。但 git commit -am 用于提交跟踪过的文件，不可以用于 untracked file

在使用git commit命令将修改从暂存区提交到本地版本库后，只剩下最后一步将本地版本库的分支推送到远程服务器上对应的分支了

git push的一般形式为 git push <远程主机名> <本地分支名> <远程分支名> ，例如 git push origin master：refs/for/master ，即是将本地的master分支推送到远程主机origin上的对应master分支， origin 是远程主机名


			
